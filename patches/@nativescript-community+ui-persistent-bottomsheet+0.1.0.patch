diff --git a/node_modules/@nativescript-community/ui-persistent-bottomsheet/index.js b/node_modules/@nativescript-community/ui-persistent-bottomsheet/index.js
index 9c55e07..9a001d0 100644
--- a/node_modules/@nativescript-community/ui-persistent-bottomsheet/index.js
+++ b/node_modules/@nativescript-community/ui-persistent-bottomsheet/index.js
@@ -91,6 +91,9 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
         if (this.steps.length === 0 || (this.steps.length === 1 && this.steps[0] === 0)) {
             return false;
         }
+        if (!data || data.y === undefined) {
+            return false;
+        }
         let deltaY = 0;
         if (__IOS__ && !this.iosIgnoreSafeArea) {
             deltaY -= Utils.layout.toDeviceIndependentPixels(this.getSafeAreaInsets().top);
@@ -126,6 +129,10 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
             this.scrollView.on('scroll', this.onScroll, this);
             this.scrollView.on('touch', this.onTouch, this);
         }
+        // Also listen to touch events on bottomSheet itself to catch events from @tap elements
+        if (this.bottomSheet) {
+            this.bottomSheet.on('touch', this.onTouch, this);
+        }
         if (this.gestureEnabled) {
             this.initGestures();
         }
@@ -136,6 +143,9 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
             this.scrollView.off('scroll', this.onScroll, this);
             this.scrollView.off('touch', this.onTouch, this);
         }
+        if (this.bottomSheet) {
+            this.bottomSheet.off('touch', this.onTouch, this);
+        }
         super.disposeNativeView();
         if (this.panGestureHandler) {
             this.panGestureHandler.off(GestureHandlerTouchEvent, this.onGestureTouch, this);
@@ -194,9 +204,9 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
         }
         this._scrollView = value;
         if (value) {
-            // if (__IOS__) {
-            //     (value.nativeViewProtected as UIScrollView).delaysContentTouches = true;
-            // }
+            if (__IOS__) {
+                value.nativeViewProtected.bounces = false; // Disable bounce to prevent acceleration
+            }
             value.on('scroll', this.onScroll, this);
             value.on('touch', this.onTouch, this);
         }
@@ -347,38 +357,82 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
             touchY = event.ios.touches.anyObject().locationInView(null).y;
         }
         if (event.action === 'down') {
+            this.touchStartY = touchY;
+            this.scrollViewTouched = false;
+            this.wasDraggingPanel = false;
+            this.gestureModeDecided = false;
         }
         else if (event.action === 'up' || event.action === 'cancel') {
-            if (this.scrollViewTouched) {
-                this.scrollViewTouched = false;
-                if (this.scrollViewAtTop) {
-                    this.scrollViewAtTop = this.scrollView.verticalOffset === 0;
-                    const y = touchY - (this.lastTouchY || touchY);
-                    const totalDelta = this.translationY + y;
-                    this.computeAndAnimateEndGestureAnimation(-totalDelta);
-                }
+
+            // If we were dragging the panel, animate to nearest step
+            if (this.wasDraggingPanel) {
+                const y = touchY - (this.lastTouchY || touchY);
+                const totalDelta = this.translationY + y;
+                this.computeAndAnimateEndGestureAnimation(-totalDelta);
+                this.wasDraggingPanel = false;
             }
+
+            this.scrollViewTouched = false;
             this.isScrollEnabled = true;
+
+            // Only reset touchStartY on 'up', not on 'cancel' (@tap elements send cancel mid-gesture)
+            if (event.action === 'up') {
+                this.touchStartY = undefined;
+            }
         }
-        else if ((!this.scrollViewTouched || this.scrollViewAtTop) && event.action === 'move') {
-            if (!this.scrollViewTouched) {
-                // on android sometimes we dont get the down event but we get move events
-                // so let init here if necessary
-                this.scrollViewTouched = true;
-                this.lastScrollY = this.scrollViewVerticalOffset;
-                this.scrollViewAtTop = this.lastScrollY === 0;
-                if (!this.scrollViewAtTop) {
-                    return;
+        else if (event.action === 'move') {
+            const deltaY = touchY - (this.touchStartY || touchY);
+            const absDeltaY = Math.abs(deltaY);
+
+            if (absDeltaY < SWIPE_DISTANCE_MINIMUM) {
+                // Movement too small - likely a tap
+                return;
+            }
+
+            // Check current scroll position
+            const currentScrollY = this.scrollViewVerticalOffset;
+            let isAtTop = currentScrollY === 0;
+
+            // If not yet dragging panel, check if we should start (one-way transition)
+            if (!this.wasDraggingPanel) {
+                let shouldStartDraggingPanel = false;
+
+                if (deltaY > 0) {
+                    // Swiping DOWN - start dragging panel if reached top
+                    shouldStartDraggingPanel = isAtTop;
+                } else {
+                    // Swiping UP - start dragging panel if at top AND panel not fully expanded
+                    if (isAtTop) {
+                        const maxOffset = this.translationMaxOffset;
+                        const isPanelFullyExpanded = Math.abs(this.translationY + maxOffset) < 1;
+                        shouldStartDraggingPanel = !isPanelFullyExpanded;
+                    }
                 }
-                else {
+
+                if (shouldStartDraggingPanel) {
+                    // Switch to panel dragging mode (one-way, won't switch back during this gesture)
+                    this.wasDraggingPanel = true;
+                    this.isScrollEnabled = false;
                     this.panGestureHandler.cancel();
+                } else {
+                    // Keep scrolling the list
+                    if (!this.gestureModeDecided) {
+                        this.gestureModeDecided = true;
+                        this.isScrollEnabled = true;
+                    }
                 }
             }
-            const y = touchY - (this.lastTouchY || touchY);
-            const trY = this.constrainY(this.translationY + y);
-            this.translationY = trY;
-            const trData = this.computeTranslationData();
-            this.applyTrData(trData);
+
+            // Execute the current mode
+            if (this.wasDraggingPanel) {
+                // Handle panel drag
+                const y = touchY - (this.lastTouchY || touchY);
+                const trY = this.constrainY(this.translationY + y);
+                this.translationY = trY;
+                const trData = this.computeTranslationData();
+                this.applyTrData(trData);
+            }
+            // else: let native scroll happen (do nothing)
         }
         this.lastTouchY = touchY;
     }
@@ -400,6 +454,11 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
         this.lastScrollY = scrollY;
     }
     onGestureState(args) {
+        // Ignore pan gesture handler when we're manually dragging panel via onTouch
+        if (this.wasDraggingPanel) {
+            return;
+        }
+
         const { state, prevState, extraData, view } = args.data;
         if (prevState === GestureState.ACTIVE) {
             const { velocityY, translationY } = extraData;
@@ -428,6 +487,11 @@ let PersistentBottomSheet = class PersistentBottomSheet extends AbsoluteLayout {
         this.animateToPosition(destSnapPoint, Math.min(distance * 2, OPEN_DURATION));
     }
     onGestureTouch(args) {
+        // Ignore pan gesture handler when we're manually dragging panel via onTouch
+        if (this.wasDraggingPanel) {
+            return;
+        }
+
         const data = args.data;
         if (data.state !== GestureState.ACTIVE) {
             return;
